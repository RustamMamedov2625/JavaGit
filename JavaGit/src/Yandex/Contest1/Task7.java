package Yandex.Contest1;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

public class Task7 {
    public static void calculateStrategy() {
        // Создание объекта Scanner для чтения входных данных
        Scanner scanner = new Scanner(System.in);

        // Чтение значений x, y и p из стандартного ввода
        int x = scanner.nextInt();
        int y = scanner.nextInt();
        int p = scanner.nextInt();

        // Проверка, если y меньше или равно x, то выводим 1 и завершаем программу
        if (y <= x) {
            System.out.println(1);
            System.exit(0);
        }

        // Инициализация переменной ans и вычитание x из y
        int ans = 1;
        y -= x;
        int cur_p = p;

        // Проверка условий и вычисление ответа
        if (y <= 0 && x >= cur_p) {
            System.out.println(1);
        } else {
            while (true) {
                // Проверка условий и выход из цикла, если они выполнены
                if (y <= 0 && x >= cur_p) {
                    if (cur_p <= 0) {
                        System.out.println(ans);
                    } else {
                        System.out.println(ans + 1);
                    }
                    break;
                }
                if (y > 0) {
                    if (cur_p >= x && y >= x) {
                        System.out.println(-1);
                        break;
                    }
                    if (y < x) {
                        int result = model(x, cur_p, y);
                        if (result == 100000000) {
                            System.out.println(-1);
                        } else {
                            System.out.println(ans + result);
                        }
                        break;
                    } else {
                        y -= x - cur_p;
                    }
                } else {
                    if (x <= 0) {
                        System.out.println(-1);
                        break;
                    }
                    cur_p -= x;
                    x -= cur_p;
                }
                ans += 1;
            }
        }
    }

    public static int model(int x, int p, int y) {
        // Инициализация переменной ans и счетчика cnt
        int ans = 100000000;
        int cnt = 0;

        // Создание списка для хранения случаев
        List<int[]> cases = new ArrayList<>();
        cases.add(new int[]{0, x, p, y});
        int y1 = y;

        // Генерация случаев
        if (x - p > 0) {
            while (y1 > 0) {
                cnt += 1;
                if (y1 - (x - p) <= 0) {
                    cases.add(new int[]{cnt, x, p - (x - y1), 0});
                    y1 = 0;
                } else {
                    y1 = y1 - (x - p);
                    cases.add(new int[]{cnt, x, p, y1});
                }
            }
        }

        // Обработка случаев
        for (int[] res : cases) {
            if (res[3] == 0 && res[2] <= 0) {
                ans = Math.min(ans, res[0]);
                continue;
            }

            // Вычисление новых значений cur_x и cur_p
            int cur_x = 2 * res[1] - res[2] - res[3];
            int cur_p = res[2] - (res[1] - res[3]);
            boolean fl = false;
            int k = 1;

            // Проверка условий и обновление ans
            while (true) {
                k += 1;
                cur_p -= cur_x;
                cur_x -= cur_p;
                if (cur_x < 0) {
                    break;
                }
                if (cur_x == 0 && cur_p > 0) {
                    break;
                }
                if (cur_p <= 0) {
                    fl = true;
                    break;
                }
            }
            if (fl) {
                ans = Math.min(ans, res[0] + k);
            }
        }
        return ans;
    }
}

/*G. Разрушить казарму
Ограничение времени	1 секунда
Ограничение памяти	256Mb
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt
Вы играете в интересную стратегию. У вашего соперника остались всего одна казарма — здание, в котором постоянно появляются новые солдаты. Перед атакой у вас есть x солдат. За один раунд каждый солдат может убить одного из солдат противника или нанести 1 очко урона казарме (вычесть единицу здоровья у казармы). Изначально у вашего оппонента нет солдат. Тем не менее, его казарма имеет y единиц здоровья и производит p солдат за раунд.

Ход одного раунда:

Каждый солдат из вашей армии либо убивает одного из солдат вашего противника, либо наносит 1 очко урона казарме. Каждый солдат может выбрать своё действие. Когда казарма теряет все свои единицы здоровья, она разрушается.
Ваш противник атакует. Он убьет k ваших солдат, где k — количество оставшихся у противника солдат.
Если казармы еще не разрушены, ваш противник производит p новых солдат.
Ваша задача — разрушить казарму и убить всех солдат противника. Если это возможно, посчитайте минимальное количество раундов, которое вам нужно для этого. В противном случае выведите -1.

Формат ввода
На вход подаётся три целых числа x, y, p (1 ? x, y, p ? 5000) — количество ваших солдат на старте игры, количество очков здоровья казармы и количество производимых за раунд казармой солдат, соответственно. Каждое число расположено в новой строке.

Формат вывода
Если возможно убить всех вражеских солдат и разрушить казарму, выведите минимальное количество раундов, необходимых для этого. В противном случае выведите -1.

Пример 1
Ввод	Вывод
10
11
15
4
Пример 2
Ввод	Вывод
1
2
1
-1
Пример 3
Ввод	Вывод
1
1
1
1
Пример 4
Ввод	Вывод
25
200
10
13
Примечания
В первом примере в первом раунде сначала все ваши солдату атакуют казарму, после этого не происходит ничего, потому что у врага нет солдат, затем у врага появляется 15 солдат.
Во втором раунде один ваш солдат добивает казарму, остальные 9 солдат убивают 9 солдат врага. Оставшиеся 6 солдат врага убивают 6 ваших солдат, но армия врага не пополняется, поскольку казарма разрушена. В третьем раунде сначала вы убиваете четверых солдат врага, затем враг двоих ваших солдат.
 В последнем, четвертом, раунде вы добиваете двух оставшихся солдат врага.*/